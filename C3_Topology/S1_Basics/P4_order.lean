import Mathlib.Data.Set.Basic
import Mathlib.Data.Prod.Lex
import Mathlib.Topology.Order
import Mathlib.Topology.Bases
import Mathlib.Data.Real.Basic
import Mathlib.Data.Set.Intervals.Basic
open TopologicalSpace

/-
# Order Topology
Given a space X with a Linear Order, we can define a topology on X called
the order topology. The order topology on X is generated by a basis which
consists of all open intervals and open rays.


-/

def ordBasis {X : Type} [LinearOrder X] : Set (Set X) :=
  {S : Set X | S = Set.univ ∨ ∃ x : X, S = Set.Iio x ∨ S = Set.Ioi x ∨ ∃ y : X, S = Set.Ioo x y}

instance T_X {X : Type} [LinearOrder X] : TopologicalSpace X :=  generateFrom (ordBasis)

theorem validBasis {X : Type} [LinearOrder X] : @IsTopologicalBasis X (T_X) (ordBasis) where
  exists_subset_inter := by
    rintro B₁ hB₁ B₂ hB₂ x xB₃
    exists B₁ ∩ B₂
    refine ⟨?_, xB₃, subset_refl _⟩
    dsimp [ordBasis] at *
    rcases hB₁ with (B₁univ | ⟨x₁, h₁⟩)
    rcases hB₂ with (B₂univ | ⟨x₂, h₂⟩)
    · apply Or.inl
      rw [B₁univ, B₂univ, Set.univ_inter]
    sorry
    sorry
  sUnion_eq := by
    rw [Set.sUnion_eq_univ_iff]
    intro x
    exists Set.univ
    refine ⟨?_, trivial⟩
    apply Or.inl
    rfl
  eq_generateFrom := rfl

def Top_of_LinOrder {X : Type} : LinearOrder X → TopologicalSpace X := λ _ ↦ T_X

noncomputable section

instance : TopologicalSpace ℝ := by
  apply Top_of_LinOrder
  infer_instance

-- The order topology on ℝ is the standard topology on ℝ.
-- The standard topology on ℝⁿ is the product topology, where
-- each ℝ is given the standard topology.

example : IsOpen {x : ℝ | 0 < x ∧ x < 1} := by
  apply TopologicalSpace.isOpen_generateFrom_of_mem
  dsimp [ordBasis]
  apply Or.inr
  exists 0
  apply Or.inr
  apply Or.inr
  exists 1

example : IsClosed {x : ℝ | x ≤ 0} := by
  suffices h : IsOpen {x : ℝ | x ≤ 0}ᶜ
  · exact { isOpen_compl := h }
  apply TopologicalSpace.isOpen_generateFrom_of_mem
  dsimp [ordBasis]
  apply Or.inr
  exists 0
  apply Or.inr
  apply Or.inl
  ext x
  simp only [Set.mem_compl_iff, Set.mem_setOf_eq, not_le, Set.mem_Ioi]

example : IsOpen {x : ℝ | x * x < 1} := by
  sorry

lemma single_not_open : ∀ x : ℝ, ¬ IsOpen {x} := by
  intro x
  rw [IsTopologicalBasis.isOpen_iff validBasis]
  push_neg
  exists x
  use rfl
  intro S hS xS Ssub
  rcases hS with (Suniv | ⟨a, (hSio | hSoi | ⟨b, hSoo⟩)⟩)
  · sorry
  · sorry
  · sorry
  · sorry


example : IsOpen {p : ℝ × ℝ | p.1 < 0} := by
  have : IsOpen ((Set.Iio 0 ×ˢ Set.univ) : Set (ℝ × ℝ)) := by
    apply IsOpen.prod
    · apply TopologicalSpace.isOpen_generateFrom_of_mem
      dsimp [ordBasis]
      apply Or.inr
      exists 0
      apply Or.inl
      rfl
    · exact isOpen_univ
  have : ((Set.Iio 0 ×ˢ Set.univ) : Set (ℝ × ℝ)) = {p | p.fst < 0} := by
    ext ⟨x, y⟩
    simp only [Set.mem_prod, Set.mem_Iio, Set.mem_univ, and_true, Set.mem_setOf_eq]
  rw [←this]
  assumption

def T₁ : TopologicalSpace (ℝ × ℝ) := by infer_instance

#check Prod.Lex.linearOrder

instance : LinearOrder (ℝ × ℝ) := Prod.Lex.linearOrder ℝ ℝ

def T₂ : TopologicalSpace (ℝ × ℝ) := Top_of_LinOrder (by infer_instance)

-- Let's show that the lexicographic order on ℝ ⨯ ℝ generates a
-- different topology from the product topology.
example : T₁ ≠ T₂ := by
  dsimp only [ne_eq]
  rw [TopologicalSpace.ext_iff]
  push_neg
  -- Big Idea: a thin fiber is open in the lexicographic order topology,
  -- but not in the product topology.
  exists ({0} ×ˢ Set.Ioo 0 2)
  apply Or.inr
  apply And.intro
  · rw [isOpen_prod_iff]
    push_neg
    exists 0, 1
    apply And.intro
    · sorry
    intro S T openS _ zeroS oneT
    rw [Set.prod_subset_prod_iff]
    push_neg
    have aux : ∀ x : ℝ, ∀ U : Set ℝ, x ∈ U → U ≠ ∅ := by
      sorry
    refine ⟨?_, aux 0 S zeroS, aux 1 T oneT⟩
    intro h
    replace h : S = {0} := by
      sorry
    intro _
    apply single_not_open 0
    rw [←h]
    exact openS
  · apply TopologicalSpace.isOpen_generateFrom_of_mem
    dsimp [ordBasis]
    apply Or.inr
    exists (0, 0)
    apply Or.inr
    apply Or.inr
    exists (0, 2)
    dsimp [Set.Ioo]
    ext ⟨x, y⟩
    simp
    apply Iff.intro
    · rintro ⟨⟨ypos, ylt1⟩, xeq0⟩
      simp [LT.lt, Prod.lex_def]
      apply And.intro
      · apply Or.inr
        use xeq0
        exact ypos
      · apply Or.inr
        exact ⟨Eq.symm xeq0, ylt1⟩
    · rintro ⟨h₁, h₂⟩
      simp only [LT.lt, Prod.lex_def] at h₁ h₂
      rcases h₁ with (h | ⟨xeq0, ypos⟩)
      · apply False.elim
        apply lt_irrefl (0 : ℝ)
        replace h : 0 < x := h
        apply lt_of_lt_of_le h
        rcases h₂ with (h₂ | h₂)
        · apply le_of_lt
          exact h₂
        · apply le_of_eq
          exact h₂.1
      rcases h₂ with (xneg | ⟨xeq0, ylt1⟩)
      · apply False.elim
        apply lt_irrefl (0 : ℝ)
        rw [←xeq0] at xneg
        exact xneg
      · exact ⟨⟨ypos, ylt1⟩, Eq.symm xeq0⟩


end
